# Upgrading

## Upgrading to Torch 6.0.0 (Scrivener to Flop Migration)

Torch 6.0.0 introduces a significant change by migrating from Scrivener to Flop for pagination, filtering, and sorting. This migration provides more advanced features while maintaining backward compatibility.

### What's Changed

1. **Dependencies**: Torch now includes both Scrivener and Flop, with Flop being the primary pagination library.
2. **API Compatibility**: A `Torch.FlopAdapter` module bridges between Scrivener and Flop APIs to maintain backward compatibility.
3. **New Features**: Flop provides additional capabilities like cursor-based pagination, compound fields, and more advanced filtering.

### Backward Compatibility

Existing code that uses Torch's pagination should continue to work without changes. The following functions maintain backward compatibility:

- `Torch.Helpers.paginate/4`
- `Torch.Pagination` module
- `Torch.PaginationView.pagination/1`

### Using Flop Directly (Recommended for New Code)

For new applications or when enhancing existing ones, we recommend using Flop directly:

```elixir
# In your controller
def index(conn, params) do
  {:ok, {users, meta}} = 
    User
    |> Flop.validate_and_run(params, for: User)
    
  render(conn, "index.html", users: users, meta: meta)
end

# In your view
def pagination(conn, meta) do
  Torch.PaginationView.pagination_from_meta(conn, meta)
end
```

### New Functions for Flop Integration

Torch provides new functions for working directly with Flop:

- `Torch.PaginationView.pagination_from_meta/2` - Renders pagination links from a Flop.Meta struct
- `Torch.TableView.flop_table_link/3` - Generates sortable table headers with Flop parameters

### Migrating Existing Code to Flop

While not required, migrating to Flop directly provides access to more advanced features:

1. **Update Schema**: Add `@derive {Flop.Schema, ...}` to your Ecto schemas to define filterable and sortable fields:

```elixir
@derive {Flop.Schema, 
  filterable: [:name, :email, :status],
  sortable: [:name, :email, :inserted_at]
}
schema "users" do
  # ...
end
```

2. **Update Controllers**: Replace Scrivener pagination with Flop:

```elixir
# Before (with Scrivener)
def index(conn, params) do
  page =
    User
    |> Repo.paginate(params)
  
  render(conn, "index.html", users: page.entries, page: page)
end

# After (with Flop)
def index(conn, params) do
  {:ok, {users, meta}} =
    User
    |> Flop.validate_and_run(params, for: User)
  
  render(conn, "index.html", users: users, meta: meta)
end
```

3. **Update Views**: Use the new Flop-compatible pagination function:

```elixir
# Before
<%= Torch.PaginationView.pagination(@conn) %>

# After
<%= Torch.PaginationView.pagination_from_meta(@conn, @meta) %>
```

4. **Update Table Headers**: Use the Flop-compatible table link function:

```elixir
# Before
<%= table_link(@conn, "Name", :name) %>

# After
<%= flop_table_link(@conn, "Name", :name) %>
```

### Advanced Flop Features

Flop provides several advanced features not available in Scrivener:

1. **Cursor-based Pagination**: More efficient for large datasets:

```elixir
flop_params = %{
  "first" => 10,
  "after" => cursor
}
```

2. **Compound Fields**: Filter on multiple fields with a single parameter:

```elixir
@derive {Flop.Schema, 
  filterable: [:name, :email],
  compound_fields: [full_text: [:name, :email]]
}
```

3. **Custom Fields**: Define custom filter logic:

```elixir
@derive {Flop.Schema, 
  custom_fields: [
    %{name: :age_range, filter: {MyApp.CustomFilters, :filter_by_age_range}}
  ]
}
```

For more information on using Flop's advanced features, see the [Flop documentation](https://hexdocs.pm/flop/readme.html).

### Torch v4 to Torch v5

Torch v5 **IS NOT ** fully backwards compatible with Torch v4.  Due to Phoenix 1.7 dropping the inclusion
of `Phoenix.View` in the core SDK, the way the templates are created, and the content of the templates
generated by Torch have changed significantly.

There is no automatic upgrade path for existing files that were generated with previous versions of Torch.
If you encounter issues using Torch v5 with existing templates, you can either continue to use Torch v4,
or manually update your existing Torch templates to the new unified function component style
provided by `Torch.Component`.

Templates that were generated with Torch v4 _should_ still funtion, if you manaully included `:phoenix_view`
in your projects mix dependencies, but your results may vary.  For templates generated with Torch v4, you
would also need to make the manual updates described below in the "Torch v3 to Torch v4" section.

#### Slime support dropped

Torch v5 has dropped support for Slime templates.  Only heex templates
are now supported.

### Torch v3 to Torch v4

Torch v4 **IS NOT** fully backwards compatible with Torch v3.  In particular, the templates have changed
in a manner that affect the generated DOM and CSS rules used.

To manually update your existing templates to the new v4 DOM do the following:

#### show.html.*

* `<div class="header"></div>` becomes `<header class="header"></header>`
* `<ul><li>...</li></ul>` list for model properties becomes `<section class="torch-show-details"><div class="torch-show-attribute">...</div></section>`

#### form.html.*

Inside `<div class="torch-form-group>...</div>`, the `input` and `error` outputs are now wrapped in an additional div:

    <div class="torch-form-group">
      <%= label %>
      <%= input %>
      <%= error %>
    </div>

becomes:

    <div class="torch-form-group">
      <%= label %>
      <div class="torch-form-group-input">
        <%= input %>
        <%= error %>
      </div>
    </div>


Another option to "upgrade" is to just generate new templates again via the Torch v4 generators.  Run the same
generator commands as the first time and overwrite your existing files.  Then resolve any customization previously
made to your Torch v3 templates by re-applying those change to the newly generated Torch v4 templates.
</initial_code>
